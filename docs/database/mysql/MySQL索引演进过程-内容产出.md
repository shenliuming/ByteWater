# MySQL索引演进与性能优化实战

## 课程概述

本课程通过场景化，从实际业务问题出发，逐步深入MySQL索引的设计原理和优化策略。你将学会：

- 理解数据存储的物理基础
- 掌握索引失效的常见场景及解决方案
- 使用EXPLAIN等工具分析查询性能
- 设计高效的索引策略

## 学习路径
1. [业务场景：电商系统的性能瓶颈](#1-业务场景电商系统的性能瓶颈)
2. [技术基础：数据存储的物理原理](#2-技术基础数据存储的物理原理)
3. [问题分析：为什么查询这么慢](#3-问题分析为什么查询这么慢)
4. [解决方案：索引的演进过程](#4-解决方案索引的演进过程)
5. [实战演练：索引失效场景分析](#5-实战演练索引失效场景分析)
6. [工具实操：EXPLAIN性能分析](#6-工具实操explain性能分析)
7. [优化策略：索引设计最佳实践](#7-优化策略索引设计最佳实践)

---

## 1. 业务场景：电商系统的性能瓶颈

### 1.1 真实业务场景

你刚入职一家快速发展的电商公司，担任后端开发工程师。公司的用户量从10万增长到了1000万，但系统性能却越来越差。

**用户表结构：**
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    age INT,
    city VARCHAR(50),
    register_time DATETIME,
    last_login DATETIME
);
-- 当前数据量：1000万条记录
```

### 1.2 性能问题爆发

**场景1：用户登录**
```sql
-- 用户输入手机号登录
SELECT * FROM users WHERE phone = '13812345678';
-- 响应时间：8-12秒
```

**场景2：用户搜索**
```sql
-- 按年龄和城市筛选用户
SELECT * FROM users WHERE age BETWEEN 25 AND 35 AND city = '北京';
-- 响应时间：15-20秒
```

**场景3：数据统计**
```sql
-- 统计各城市用户数量
SELECT city, COUNT(*) FROM users GROUP BY city;
-- 响应时间：30-45秒
```

### 1.3 业务影响

- **用户体验**：登录超时，用户流失严重
- **系统负载**：数据库CPU使用率持续90%+
- **业务损失**：订单转化率下降30%
- **运维压力**：频繁的系统告警和重启

### 1.4 问题根源分析

通过监控发现，所有慢查询都有一个共同特征：**全表扫描**

```sql
-- 查看执行计划
EXPLAIN SELECT * FROM users WHERE phone = '13812345678';
```

结果显示：
- `type: ALL` (全表扫描)
- `rows: 10000000` (扫描1000万行)
- `Extra: Using where` (在内存中过滤)

**核心问题：数据必须从磁盘加载到内存才能被程序访问，而磁盘I/O是性能瓶颈的根源。**

---

## 2. 技术基础：数据存储的物理原理

### 2.1 磁盘的物理结构

要理解为什么数据库查询慢，必须先理解数据是如何存储在磁盘上的。磁盘就像一个唱片机，数据存储在旋转的盘片上。

**核心概念：**
- **磁头臂移动机制**：通过磁头臂的移动来改变磁道(Track)
- **盘片旋转机制**：通过盘片旋转来改变扇区(Sector)  
- **三坐标定位**：Track号 + Sector号 + Offset偏移量
- **块大小标准**：每个块512字节，地址从0到511

#### 盘片（Platter）
- 磁盘的核心组件，像一个圆形的盘子
- 一个磁盘可以有一个或多个盘片堆叠在一起
- 数据存储在盘片的磁性表面上

#### 磁道（Track）
- 盘片上的同心圆，这些是逻辑上的圆圈，不是物理刻痕
- 从外圈到内圈：Track 0, Track 1, Track 2, Track 3...
- 数据沿着这些磁道存储

#### 扇区（Sector）
- 每个磁道被分割成许多小段，称为扇区
- 扇区是磁盘物理上最小的读写单位
- 通常每个扇区大小为512字节（这个取决于磁盘供应商）
- 扇区编号：Sector 0, Sector 1, Sector 2...

#### 块（Block）
- 磁道和扇区的交叉位置形成了块
- 任何磁盘位置都可以用 **磁道号 + 扇区号** 来定位
- 例如：Track 1 + Sector 0 = 一个特定的块地址

```

┌─────────────────────────────────────────────────────────┐
│ ● 盘片 (Platter): 圆形磁性存储介质，类似盘子形状        │
│ ○ 磁道 (Track): 盘片上的同心圆，从外到内编号0,1,2...   │
│ | 扇区 (Sector): 磁道的分割线，垂直于盘片的射线          │
│ ■ 块 (Block): 磁道与扇区的交叉，用(Track,Sector)定位   │
└─────────────────────────────────────────────────────────┘

磁盘寻址示例：
要访问数据块需要三个坐标：
• 磁道号 (Track Number): 确定在哪个同心圆
• 扇区号 (Sector Number): 确定在磁道的哪个位置  
• 偏移量 (Offset): 在扇区内的字节位置(0-511)
```

### 2.2 磁盘寻址机制

磁盘上的任何一个字节都可以通过三个坐标来精确定位：

1. **磁道号（Track Number）**：确定在哪个同心圆上
2. **扇区号（Sector Number）**：确定在磁道的哪个位置  
3. **偏移量（Offset）**：在512字节块内的具体字节位置（0-511）

**示例**：要读取Track 1, Sector 0位置的第10个字节
- 地址表示为：`(Track=1, Sector=0, Offset=10)`
- **磁头定位过程**：磁头臂移动到Track 1 → 盘片旋转到Sector 0 → 读取偏移量10的字节

**关键理解**：磁盘读写总是以块为单位，任何字节的访问都需要先定位到对应的块，然后通过偏移量找到具体位置。

### 2.3 磁盘读写的物理过程

磁盘有一个**磁头臂（Head Arm）**和**读写磁头（Read/Write Head）**：

**两个核心机制：**

1. **磁头臂移动（改变磁道）**：
   - 通过磁头臂的物理移动来改变磁道位置
   - 这是一个机械过程，需要时间（寻道时间）

2. **盘片旋转（改变扇区）**：
   - 通过盘片的旋转来改变扇区位置
   - 需要等待目标扇区旋转到磁头下方（旋转延迟）

**完整的读写过程：**
1. **寻道（Seek）**: 磁头臂移动到指定磁道
2. **旋转等待（Rotational Delay）**: 等待盘片旋转，使目标扇区到达磁头下方
3. **数据传输（Data Transfer）**: 实际读取或写入数据

**关键要点**：这个过程是机械的，相对较慢，这就是为什么减少磁盘I/O次数如此重要。磁盘读写总是以块为单位进行，即使只需要一个字节，也要读取整个512字节的块。

### 2.4 磁盘I/O的时间成本

- **寻道时间（Seek Time）**: 2-10毫秒（移动磁头到指定磁道）
- **旋转延迟（Rotational Latency）**: 2-8毫秒（等待扇区旋转到位）
- **传输时间（Transfer Time）**: 0.1-1毫秒（实际读写数据）

> **关键洞察**: 磁盘I/O最耗时的部分是寻道时间和旋转延迟，也就是**随机I/O**的成本。因此，优化的关键在于**减少I/O次数**，并尽可能将随机I/O转换为**顺序I/O**。

### 2.5 索引演进：从100条记录开始的优化之路

让我们从一个具体的例子开始，看看索引是如何一步步演进的。

#### 2.5.1 起点：100条记录的存储

让我们从一个具体的例子开始。假设我们有100条员工记录，每条记录128字节：

id = 1 , name = '令狐'

id = 2 , name = '任盈盈'

id = 3 , name = '任我行'

....

如果我要改变 id = 100 这条记录的 name = '岳不群' 

**存储计算：**

- 每条记录大小：128字节
- 每个块大小：512字节  
- 每块存储记录数：512 ÷ 128 = 4条
- 100条记录需要块数：100 ÷ 4 = 25个块

```
[Block 1: 记录1-4] [Block 2: 记录5-8] [Block 3: 记录9-12] [Block 4: 13-16]...
```

**查找问题：**

- 无索引时：我们不知道记录在哪里。所以我们必须在表格中搜索。因此，我们最多只能访问25个街区。 最坏情况需要访问所有4个块
- 平均访问：2.5个块

### 2.5.2 第一次优化：创建索引

为了提高查找效率，我们创建索引：

**索引结构：**
- 索引项结构：(主键值, 块地址) = 8字节
- 每块索引项数：512 ÷ 8 = 64个
- 100个索引项需要：约4个块（实际存储需要）

```
索引结构：
[索引块1] [索引块2] [索引块3] [索引块4]
     ↓         ↓         ↓         ↓
[数据块1-4: 实际记录]
```

**优化效果：**
- 索引查找：最多访问4个索引块
- 数据访问：1个数据块
- 总计：最多5个块（4个索引块 + 1个数据块）

### 2.5.3 数据量增长：1000条记录的挑战

随着业务发展，数据量增长到1000条记录：

**存储需求：**
- 1000条记录需要：1000 ÷ 25 = 40个数据块
- 1000个索引项需要：约40个索引块

```
索引结构：
[索引块1] [索引块2] ... [索引块40]
     ↓         ↓              ↓
[数据块1-40: 实际记录]
```

**新问题出现：**
- 查找一条记录需要：40个索引块 + 1个数据块 = 41个块
- 索引本身成为了性能瓶颈！

### 2.5.4 第二次优化：多级索引的引入

当索引变得庞大时，我们需要"索引的索引"：

**二级索引设计：**
- 稀疏索引：每个一级索引块对应一个二级索引项
- 40个一级索引块 → 40个二级索引项
- 每块可存储：512 ÷ 16 = 32个稀疏索引项
- 二级索引需要：40 ÷ 32 ≈ 2个块

```
多级索引结构：
    [二级索引块1-2: 40个索引项]
           ↓
    [一级索引块1-40: 1000个索引项]
           ↓
    [数据块1-40: 1000条记录]
```

**优化效果：**
- 二级索引访问：2个块
- 一级索引访问：1个块  
- 数据访问：1个块
- 总计：4个块（从41个块优化到4个块！）

### 2.5.5 继续增长：更大数据量的扩展

**自动索引层级管理：**

当数据继续增长时，系统会自动添加更多索引层级：

- **数据量增长**：如果二级索引也变得很大，系统会自动创建三级索引
- **数据量减少**：如果删除记录导致索引层级过多，系统会自动删除多余的索引层级
- **动态调整**：索引层级的增加和删除都是自动进行的，无需手动干预

**关键特性：**
1. **稀疏索引**：上级索引不为每个下级索引项创建条目，而是为每个下级索引块创建一个指针
2. **自动管理**：根据数据量的变化自动增减索引层级
3. **对数复杂度**：无论数据量如何增长，查找时间始终保持在对数级别

### 2.5.6 索引演进的核心洞察

通过这个演进过程，我们发现了几个关键点：

1. **索引的本质**：用空间换时间，通过额外存储换取查找效率
2. **多级索引的威力**：数据量指数增长，查找次数对数增长  
3. **稀疏索引的智慧**：上级索引不需要包含所有下级条目，只需要指向下级块
4. **自动管理的必要性**：索引层级需要根据数据量自动增减

**自动管理机制：**
- 当数据量增长，索引块数增加时，自动添加上级索引
- 当数据量减少，索引块数减少时，自动删除多余的索引层级
- 这种自动管理确保了查找效率始终保持在对数级别

这种多级索引的思想，正是B树和B+树的理论基础！通过这种层级结构，我们可以将任意大小的数据集的查找时间控制在可接受的范围内。

### 2.6 从多级索引到树结构：M路搜索树的诞生

当我们将多级索引的结构侧过来看时，会发现它们看起来就像一棵树！这种观察引出了一个重要的概念：**M路搜索树（M-way Search Tree）**。

#### 2.6.1 回顾二叉搜索树

在理解M路搜索树之前，让我们先回顾一下熟悉的**二叉搜索树**：

```
二叉搜索树示例：
        25
       /  \
      15   40
     / \   / \
    10 20 30 60
```

**二叉搜索树的特点：**
- **每个节点只有一个键值**
- **每个节点最多有两个子节点**（左子树和右子树）
- **左子树的所有键值 < 根节点键值 < 右子树的所有键值**
- **查找过程**：从根开始，键值小于当前节点则向左，大于则向右

**查找示例**：查找键值15
1. 从根节点25开始：15 < 25，向左
2. 到达节点15：15 = 15，找到！

#### 2.6.2 M路搜索树的概念

既然二叉搜索树每个节点只能有1个键值和2个子节点，那么我们能否创建一个节点有**多个键值**和**多个子节点**的搜索树呢？答案是肯定的！

**M路搜索树示例（M=4，即4路搜索树）：**

```
M路搜索树示例：
        [20, 50]
       /    |    \
   [10,15] [30,35] [60,90]
```

**M路搜索树的特点：**
- **每个节点可以有多个键值**（最多M-1个）
- **每个节点最多有M个子节点**
- **键值在节点内按升序排列**
- **子节点的键值范围由父节点的键值分割**

#### 2.6.3 M路搜索树的查找过程

**查找示例**：在上面的4路搜索树中查找键值30

1. **从根节点[20, 50]开始**：
   - 30 > 20 且 30 < 50
   - 所以30应该在中间的子树中

2. **进入中间子节点[30, 35]**：
   - 30 = 30，找到！

**查找的时间复杂度**：
- 虽然在单个节点内的比较次数增加了
- 但是树的高度显著降低了
- 总体查找效率通常比二叉搜索树更好

#### 2.6.4 M路搜索树与多级索引的关系

现在我们可以看到，**多级索引实际上就是一种M路搜索树**：

```
多级索引结构：
    [二级索引块1-2: 40个索引项]
           ↓
    [一级索引块1-40: 1000个索引项]
           ↓
    [数据块1-40: 1000条记录]

等价的M路搜索树结构：
        [索引项1, 索引项2, ..., 索引项40]
       /         |         |         \
   [数据块1] [数据块2] ... [数据块40]
```

**关键洞察：**
1. **自动管理的多级索引** = **自平衡的M路搜索树**
2. **稀疏索引的概念** = **树的内部节点只存储导航信息**
3. **索引块的分裂与合并** = **树节点的分裂与合并**

#### 2.6.5 从M路搜索树到B树

M路搜索树为我们提供了理论基础，但在实际应用中还需要解决几个问题：

1. **平衡性问题**：如何保证树始终保持平衡？
2. **节点利用率**：如何保证节点不会过于稀疏？
3. **动态调整**：如何在插入和删除时维护树的性质？

这些问题的解决方案，就是我们即将讨论的**B树（B-Tree）**！

**核心思想演进：**
```
磁盘块存储 → 多级索引 → M路搜索树 → B树 → B+树
```

B树和B+树实际上是**带有严格规则的M路搜索树**，这些规则确保了：
- 树始终保持平衡
- 节点利用率保持在合理范围
- 查找、插入、删除的性能都能得到保证

## 3. Page页：MySQL与磁盘交互的桥梁

### 3.1 为什么需要Page？

直接操作磁盘块（Block）对于数据库管理系统来说过于底层和低效。为了更好地管理数据并优化I/O，MySQL的InnoDB存储引擎引入了**页（Page）**作为其与磁盘交互的基本单位。

- **定义**: Page是InnoDB在内存（Buffer Pool）和磁盘之间进行数据交换的逻辑单元。
- **大小**: 默认为 `16KB`。这个大小是经过精心设计的，旨在一次I/O中尽可能多地加载数据，同时又不会造成过大的内存浪费。

> **关键思想**: MySQL不再零散地请求磁盘上的小块数据，而是每次都以一个完整的 `16KB` 的Page为单位进行读写。这大大减少了I/O次数，是性能优化的第一步。

### 3.2 Page与磁盘块的关系

一个 `16KB` 的Page，在物理上对应着磁盘上 `32` 个连续的 `512B` 扇区（或 `4` 个 `4KB` 的块）。当MySQL需要读取某条记录时，它会找到该记录所在的Page，然后向操作系统发起一个I/O请求，将整个Page的数据从磁盘加载到内存中。


---

## 4. Page的内部结构：数据的高效组织

当一个Page被加载到内存后，MySQL如何在其中快速找到所需的数据呢？这得益于Page内部精巧的组织结构。

### 3.1 Page内的记录组织

- **行记录（User Records）**: 实际存储的用户数据。这些记录在Page内部并不是紧密排列的，而是以**单向链表**的形式连接，并且**按主键从小到大有序**。
- **页目录（Page Directory）**: 为了在Page内部实现快速查找，引入了“页目录”的概念。它存储了记录的稀疏索引（槽，Slot），类似于书的目录。通过页目录，可以在Page内部实现**二分查找**，从而快速定位到目标记录所在的大致位置，然后再顺着链表找到精确的记录。


### 3.2 多个Page的连接：数据页链表

当一张表的数据量非常大，一个Page存不下时，就需要多个Page来存储。这些Page之间通过一个**双向链表**连接起来，确保了逻辑上的连续性。

```
[Page 1] <--> [Page 2] <--> [Page 3] <--> ...
```

**此时的问题**: 尽管Page内部查找很快（二分查找），但如果要在多个Page中查找一条记录，我们仍然需要从第一个Page开始，顺着双向链表逐个Page遍历，这个过程称为**全表扫描**。当数据量巨大时，I/O成本是无法接受的。例如，查找一条记录可能需要遍历成千上万个Page，引发同样数量级的磁盘I/O。

### 3.3 Page分裂与合并

#### 有序插入（理想情况）
```
插入顺序：1, 2, 3, 4, 5, 6...
结果：直接在链表末尾添加新Page，无需调整
```

#### 无序插入（问题场景）
```
插入顺序：3, 1, 5, 2, 4, 6...
结果：触发Page分裂，大量数据移动
```

#### 分裂与合并的影响
- **性能损耗**：大量的数据移动操作
- **磁盘碎片**：频繁的分裂产生碎片
- **维护成本**：需要重新组织数据结构

---

## 5. 索引的诞生：从页目录到表目录

### 5.1 核心思想：空间换时间

为了解决全表扫描的性能灾难，索引（Index）应运而生。其核心思想借鉴了我们日常生活中最熟悉的概念——**目录**。

- **图书目录**: 为了快速找到某一章节，我们不会翻遍全书，而是先查目录，获取章节对应的页码。
- **MySQL索引**: 异曲同工。MySQL创建一个或多个特殊的Page，这些Page不存储完整的行数据，只存储**“主键（Key）”**和**“数据页的地址（Pointer）”**。这就是索引页。

### 5.2 单级索引的形成

我们将所有数据页（存放着真实数据的Page）的**最小主键**和**页地址**提取出来，存放到一个专门的索引页中。这个索引页就像是整张表的“一级目录”。

- **索引项**: `(最小主键, 页地址)`
- **查找过程**: 
    1. **加载索引页**: 首先将这个“目录页”加载到内存（1次I/O）。
    2. **在索引页中查找**: 因为索引页中的条目也是按主键有序的，所以可以利用二分查找，快速定位到目标主键应该在哪个数据页的范围内。
    3. **加载数据页**: 根据找到的页地址，直接加载对应的数据页（第2次I/O）。
    4. **在数据页中查找**: 在数据页内部再次使用二分查找（页目录），找到最终的记录。

> **效果**: 通过增加一个索引页（空间换时间），我们将可能需要成千上万次的I/O操作，锐减到了固定的**2次I/O**！

### 5.3 当单级索引也变得巨大

单级索引极大地提升了查询效率，但如果数据量持续增长，例如达到千万甚至上亿级别，那么存放索引项的“目录页”本身也会变得非常庞大。一个索引页存不下，就需要多个索引页。

**问题出现了**：当索引本身也需要占用几十、几百个Page时，我们查找一个索引项，就又退化成了在“索引表”内部的全表扫描，需要遍历多个索引页，I/O成本再次飙升。

### 5.4 多级索引：给索引建立索引

解决方案是递归的：既然索引本身也是一张“表”，我们同样可以为它建立一个更高级别的索引。

- **二级索引的构建**: 我们不再为每一条索引项建立索引，而是为**每一个存储一级索引的Page**建立一个索引项。这个新的索引项包含**该索引Page中最小的主键**和**指向该索引Page的指针**。
- **稀疏索引**: 这种更高级别的索引是“稀疏”的，它只为每个索引块（Page）建立一个条目，而不是为每个数据条目都建立索引。这使得高层索引非常小。

**查找过程的演变**:
1.  **加载二级索引页**：加载最高层的索引页（1次I/O）。
2.  **在二级索引页中查找**: 快速定位到目标Key所在的一级索引Page的地址。
3.  **加载一级索引页**: 根据地址加载对应的一级索引页（第2次I/O）。
4.  **在一级索引页中查找**: 快速定位到目标Key所在的数据Page的地址。
5.  **加载数据页**: 加载最终的数据页（第3次I/O）。

> **效果**: 通过增加一个索引层级，我们将对索引的扫描，变成了又一次高效的索引查找。即使数据表有50个数据页，一级索引有40个索引页，我们也不需要 `40+1` 次I/O，而是 `1(二级索引) + 1(一级索引) + 1(数据页)` = **3次I/O**。

如果数据量继续增长，导致二级索引也变得庞大，我们可以继续向上建立三级、四级索引。这种层层递进的结构，就是B+树的雏形。

---

## 6. B树：带规则的M路搜索树

多级索引虽然解决了层级问题，但其结构松散，插入和构建过程缺乏统一规范。如果随意构建，可能导致树严重不平衡，甚至退化成链表，失去索引的优势。为了解决这个问题，**B树（B-Tree）**，即**多路平衡查找树**，应运而生。

B树可以看作是带有严格规则的多级索引，这些规则强制树保持平衡，从而保证查询效率。

### 6.1 B树的规则

1.  **节点填充率限制**: 除根节点外，每个节点至少要填充一半（`M/2`，向上取整）。例如，一个10路（degree=10）的B树，每个节点必须至少有5个子节点。这个规则强制性地让节点尽可能“丰满”，有效控制了树的高度。
2.  **根节点的特殊性**: 根节点可以不受上述规则限制，最少可以只有2个子节点（即1个键）。这是为了保证树可以从一个空的根节点开始构建。
3.  **所有叶子节点在同一层**: 这确保了任何查询的路径长度都大致相同，查询性能稳定。

### 6.2 B树的节点结构与问题

在B树中，每个节点不仅存储了键（Key）和指向子节点的指针（Child Pointer），它还存储了**指向实际数据记录的指针（Record Pointer）**。这意味着，任何一个节点，无论是叶子节点还是非叶子节点，都可能包含指向真实数据的指针。



**B树的问题**: 
1.  **存储容量受限**: 由于非叶子节点也存储数据指针，这挤占了存储子节点指针的空间。导致每个节点能容纳的索引项（分支）变少，树的“扇出”（fan-out）降低。为了存储同样多的数据，B树可能需要比B+树更高的高度，意味着更多的I/O。
2.  **范围查询效率低下**: B树的键和数据分散在整棵树中。如果要进行范围查询（如 `WHERE id > 100`），需要对树进行复杂的中序遍历，可能涉及大量的回溯和跨层级的节点访问，效率很低。

正是为了解决B树的这些问题，它的终极优化版——B+树，才登上了历史舞台。

> **关键洞察**: B+树的设计哲学回归了我们最初的多级索引思想。它不再是一个传统的搜索树，而更像是一个**完美的多级索引系统**：非叶子节点充当索引目录，叶子节点存储所有数据，链表连接实现顺序访问。这种设计将树结构的查找效率与索引系统的存储优势完美结合。

---

## 7. B+树：索引的最终形态

B+树在B树的基础上进行了关键的优化，使其更适合作为数据库的索引结构。理解B+树的关键在于：**B+树更像是一个多级索引系统**，而不是传统意义上的搜索树。

### 7.1 B+树的核心特性

B+树相对于B树有四个关键的改变，这些改变使其成为数据库索引的完美选择：

#### 1. 所有键值最终都会出现在叶子节点中
与B树不同，B+树中的**所有键值都会在叶子节点中出现**。即使某个键值在非叶子节点中作为索引出现，它也必须在叶子节点中再次出现。这确保了所有数据都能在叶子层找到。

#### 2. 非叶子节点只存储索引，不存储记录指针
这是与B树最核心的区别。B+树的非叶子节点（内部节点）**只存储键（Key）和指向下一层节点的指针（Child Pointer）**，绝不存储指向真实数据记录的指针（Record Pointer）。

```
B树节点：[Key1|RecordPtr1|ChildPtr1|Key2|RecordPtr2|ChildPtr2|...]
B+树内部节点：[Key1|ChildPtr1|Key2|ChildPtr2|Key3|ChildPtr3|...]
```

#### 3. 记录指针只存在于叶子节点
**所有指向真实数据记录的指针（Record Pointer）都只存在于叶子节点中**。这意味着：
- 任何数据查询都必须走到叶子节点才能获取到真实数据
- 查询路径长度固定，性能稳定可预期
- 非叶子节点可以存储更多的索引项，增加树的"扇出"

#### 4. 叶子节点通过双向链表连接形成稠密索引
所有叶子节点通过指针相互连接，形成一个**有序的双向链表**，这构成了**稠密索引**（Dense Index）：
- **稠密性**：每个数据记录都在叶子节点中有对应的索引项
- **有序性**：叶子节点按键值顺序排列
- **连续性**：通过链表可以顺序访问所有数据



### 7.2 B+树 vs B树：本质区别

| 特性 | B树 | B+树 |
|------|-----|------|
| **数据存储位置** | 所有节点都可存储数据 | 只有叶子节点存储数据 |
| **键值分布** | 键值分散在各层 | 所有键值都在叶子节点 |
| **非叶子节点内容** | 键值 + 数据指针 + 子节点指针 | 键值 + 子节点指针 |
| **叶子节点连接** | 无连接 | 双向链表连接 |
| **范围查询** | 需要中序遍历 | 链表顺序遍历 |
| **树的高度** | 相对较高 | 相对较矮（扇出更大） |
| **索引类型** | 稀疏索引 | 稠密索引 |

### 7.3 为什么说B+树更像多级索引？

B+树的设计哲学更接近于我们之前讨论的**多级索引系统**：

1. **非叶子节点 = 索引目录**：只存储"目录信息"（键值和指针），不存储实际数据
2. **叶子节点 = 数据页**：存储所有的实际数据记录
3. **链表连接 = 顺序访问**：叶子节点的链表结构支持高效的顺序和范围访问
4. **稠密索引特性**：每个数据记录都有对应的索引项

这种设计使得B+树在保持树结构优势的同时，又具备了索引系统的所有优点。

### 7.4 B+树的巨大优势

#### 1. 极高的存储容量
由于非叶子节点只存索引，一个 `16KB` 的Page可以存放上千个索引项（例如，`BIGINT`主键8字节 + 指针6字节 = 14字节，16KB / 14B ≈ 1170个）。这意味着一个高度为3的B+树，其叶子节点可以达到 `1170 * 1170` 个。如果每个叶子节点（数据页）能存100条记录，那么这棵树就能存储超过 `1170 * 1170 * 100` ≈ 1.3亿条数据。**上亿条数据，只需要3次磁盘I/O即可查到！**

#### 2. 高效的范围查询
B树的范围查询是其软肋，而B+树通过叶子节点的双向链表完美解决了这个问题：
- **B树范围查询**：需要复杂的中序遍历，可能涉及多次回溯和跨层访问
- **B+树范围查询**：定位到起始点后，沿着叶子节点链表顺序遍历即可

#### 3. 稳定的查询性能
任何查询（单点或范围）都必须从根节点走到叶子节点，查询路径长度固定，I/O次数稳定可预期。这种**强制性的路径一致性**确保了性能的可预测性。

#### 4. 稠密索引的优势
B+树形成的稠密索引具有以下特点：
- **完整性**：每个数据记录都有对应的索引项
- **有序性**：支持高效的顺序访问和范围查询
- **连续性**：通过链表结构实现数据的逻辑连续性
- **一致性**：所有数据访问都通过统一的索引路径

### 7.5 B+树的存储能力计算

#### 计算示例
```
已知条件：
- Page大小：16KB
- 索引项大小（非叶子节点）：14字节（BIGINT主键8字节 + 页指针6字节）
- 数据记录大小（叶子节点）：假设为100字节

计算过程：
- 非叶子节点扇出（度）：16 * 1024 / 14 ≈ 1170
- 叶子节点容量：16 * 1024 / 100 ≈ 163条记录

- 高度为2的B+树可存储：1170 * 163 ≈ 19万条记录
- 高度为3的B+树可存储：1170 * 1170 * 163 ≈ 2.2亿条记录

结论：三层B+树可轻松存储亿级数据，查询I/O仅为3次。
```

### 7.6 主键设计的重要性

#### 为什么推荐使用自增主键？
B+树的结构特性决定了，使用**趋势递增**的主键（如自增ID）能获得最佳的插入性能。

- **有序插入**: 新数据总是追加到最后的叶子节点，当节点写满时，会直接创建一个新节点，这种“页分裂”操作非常高效，对树的其他部分影响最小。
- **无序插入（如UUID）**: 新数据需要插入到中间的某个叶子节点。这会导致该节点频繁地进行“页分裂”，将一部分数据移动到新创建的节点中，可能引发连锁反应，导致上层节点也进行分裂，性能开销远大于有序插入。

#### UUID作为主键的问题
1. **无序性**：导致频繁的Page分裂
2. **长度大**：占用更多存储空间
3. **性能差**：插入和查询效率都受影响

---

## 8. MySQL索引实战应用

### 8.1 主键索引（聚集索引）

#### 特性
- **唯一性**：一张表只有一个聚集索引
- **数据即索引**：索引顺序决定数据存储顺序
- **完整数据**：叶子节点存储完整的行数据

#### 选择规则
```
1. 显式主键 → 主键作为聚集索引
2. 唯一非空索引 → 第一个唯一非空索引
3. 隐藏rowid → MySQL自动生成6字节rowid
```

### 8.2 二级索引（辅助索引）

#### 结构特点
- **部分数据**：只存储索引列和主键值
- **多个索引**：一张表可以有多个二级索引
- **排序规则**：按索引列顺序排序

#### 组合索引示例
```sql
-- 创建组合索引
ALTER TABLE user ADD INDEX idx_age_name_phone(age, user_name, phone);

-- 等效于创建了三个索引：
-- idx_age
-- idx_age_name  
-- idx_age_name_phone
```

### 8.3 索引相关概念

#### 回表
```sql
-- 需要回表的查询
SELECT * FROM user WHERE age = 18;

过程：
1. 在二级索引中找到age=18的记录
2. 获取对应的主键值
3. 根据主键值到主键索引中查找完整记录
```

#### 覆盖索引
```sql
-- 覆盖索引查询
SELECT age, user_name FROM user WHERE age = 18;

特点：查询的所有列都在索引中，无需回表
```

#### 索引下推（Index Condition Pushdown）
```sql
-- MySQL 5.6+支持索引下推
SELECT * FROM user WHERE age = 18 AND user_name LIKE '张%';

优化：
- 5.6之前：先根据age=18回表，再过滤user_name
- 5.6之后：在索引层面同时过滤age和user_name，减少回表次数
```

### 8.4 索引优化策略

#### 最左匹配原则
```sql
-- 索引：idx_age_name_phone(age, user_name, phone)

-- 能使用索引的查询
WHERE age = 18                           -- 使用age
WHERE age = 18 AND user_name = '张三'    -- 使用age, user_name
WHERE age = 18 AND user_name = '张三' AND phone = '123' -- 使用全部

-- 不能使用索引的查询
WHERE user_name = '张三'                 -- 跳过了age
WHERE age = 18 AND phone = '123'         -- 跳过了user_name
```

## 5. 实战演练：索引失效场景分析

### 5.1 场景设定

回到我们的电商系统，经过初步优化，我们为用户表添加了一些索引：

```sql
-- 用户表结构（每条记录128字节）
CREATE TABLE users (
    user_id INT PRIMARY KEY,           -- 4字节
    username VARCHAR(50),              -- 50字节  
    email VARCHAR(100),                -- 100字节
    phone VARCHAR(20),                 -- 20字节
    age INT,                          -- 4字节
    city VARCHAR(50),                 -- 50字节
    register_time DATETIME,           -- 8字节
    last_login DATETIME               -- 8字节
    -- 总计：约244字节/记录
);

-- 添加的索引
ALTER TABLE users ADD INDEX idx_phone(phone);
ALTER TABLE users ADD INDEX idx_age_city(age, city);
ALTER TABLE users ADD INDEX idx_register_time(register_time);

-- 存储计算：
-- 块大小：16KB (MySQL默认页大小)
-- 每块记录数：16384 ÷ 244 ≈ 67条记录
-- 1000万记录需要：10000000 ÷ 67 ≈ 149,254个数据页
```

### 5.2 索引失效的常见场景

但是，添加索引后，我们发现有些查询仍然很慢。让我们分析具体的失效场景：

#### 场景1：函数操作导致索引失效

**业务需求：** 查询2023年注册的用户

```sql
-- ❌ 索引失效：函数操作
SELECT * FROM users 
WHERE YEAR(register_time) = 2023;

-- 执行计划分析
EXPLAIN SELECT * FROM users WHERE YEAR(register_time) = 2023;
-- 结果：type=ALL, rows=10000000, Extra=Using where
```

**问题分析：**
1. 需要对每条记录的register_time执行YEAR()函数
2. 索引idx_register_time无法被使用
3. 必须全表扫描149,254个数据页

**优化方案：**
```sql
-- ✅ 索引有效：范围查询
SELECT * FROM users 
WHERE register_time >= '2023-01-01' 
  AND register_time < '2024-01-01';

-- 执行计划分析
EXPLAIN SELECT * FROM users 
WHERE register_time >= '2023-01-01' AND register_time < '2024-01-01';
-- 结果：type=range, key=idx_register_time, rows=365000
```

**性能对比：**
- 失效场景：扫描149,254个数据页，耗时15-20秒
- 优化后：使用索引，扫描约5,000个数据页，耗时0.5-1秒

#### 场景2：LIKE前缀通配符导致索引失效

**业务需求：** 模糊搜索用户名

```sql
-- ❌ 索引失效：前缀通配符
SELECT * FROM users 
WHERE username LIKE '%张三%';

-- 执行计划分析
EXPLAIN SELECT * FROM users WHERE username LIKE '%张三%';
-- 结果：type=ALL, rows=10000000, Extra=Using where
```

**问题分析：**
1. 前缀通配符%使得无法利用B+树的有序性
2. 必须检查每条记录的username字段
3. 全表扫描149,254个数据页

**优化方案：**
```sql
-- ✅ 索引有效：后缀通配符
SELECT * FROM users 
WHERE username LIKE '张三%';

-- 执行计划分析
EXPLAIN SELECT * FROM users WHERE username LIKE '张三%';
-- 结果：type=range, key=idx_username, rows=1000

-- 或者使用全文索引（适合复杂搜索）
ALTER TABLE users ADD FULLTEXT(username);
SELECT * FROM users WHERE MATCH(username) AGAINST('张三' IN NATURAL LANGUAGE MODE);
```

**性能对比：**
- 失效场景：全表扫描，耗时12-15秒
- 后缀通配符：使用索引，耗时0.1-0.3秒
- 全文索引：专门优化的搜索，耗时0.05-0.1秒

##### 场景3：OR条件查询
```sql
-- ❌ 索引失效：OR连接不同列
SELECT * FROM employee 
WHERE department = 'IT' OR salary > 8000;

-- 问题分析：
-- 1. 两个条件无法同时利用索引
-- 2. 需要合并两个结果集
-- 3. 可能导致全表扫描

-- ✅ 优化方案：UNION改写
SELECT * FROM employee WHERE department = 'IT'
UNION
SELECT * FROM employee WHERE salary > 8000;

-- 或者建立组合索引
ALTER TABLE employee ADD INDEX idx_dept_salary(department, salary);
```

##### 场景4：数据类型隐式转换
```sql
-- ❌ 索引失效：类型转换
SELECT * FROM employee 
WHERE employee_id = '123';  -- employee_id是INT类型

-- 问题分析：
-- 1. MySQL需要将字符串'123'转换为数字
-- 2. 或者将所有employee_id转换为字符串比较
-- 3. 索引可能无法有效使用

-- ✅ 索引有效：类型匹配
SELECT * FROM employee 
WHERE employee_id = 123;
```

##### 场景5：复合索引最左前缀原则
```sql
-- 建立复合索引
ALTER TABLE employee ADD INDEX idx_dept_salary_name(department, salary, employee_name);

-- ❌ 索引失效：跳过最左列
SELECT * FROM employee 
WHERE salary > 8000 AND employee_name = '张三';

-- 问题分析：
-- 1. 跳过了department列
-- 2. 无法利用复合索引的有序性
-- 3. 退化为全表扫描

-- ✅ 索引有效：遵循最左前缀
SELECT * FROM employee 
WHERE department = 'IT' 
  AND salary > 8000 
  AND employee_name = '张三';
```

##### 场景6：范围查询后的列失效
```sql
-- 复合索引：idx_age_name_phone(age, employee_name, phone)

-- ❌ 部分索引失效
SELECT * FROM employee 
WHERE age > 25 AND employee_name = '张三';

-- 问题分析：
-- 1. age > 25 是范围查询，可以使用索引
-- 2. employee_name = '张三' 无法使用索引（范围查询后的列）
-- 3. 需要在age索引结果中逐一检查employee_name

-- ✅ 优化方案：调整索引顺序
ALTER TABLE employee ADD INDEX idx_name_age_phone(employee_name, age, phone);

-- 或者使用覆盖索引
SELECT age, employee_name FROM employee 
WHERE age > 25 AND employee_name = '张三';
```

##### 性能对比分析
```
数据规模：100条记录，25个磁盘块，每块4条记录

场景对比：
┌─────────────────┬──────────────┬──────────────┬────────────┐
│ 查询类型        │ 磁盘块访问   │ 记录检查     │ 响应时间   │
├─────────────────┼──────────────┼──────────────┼────────────┤
│ 全表扫描        │ 25个块       │ 100条记录    │ 最慢       │
│ 索引失效        │ 25个块       │ 100条记录    │ 最慢       │
│ 主键查询        │ 3-4个块      │ 1条记录      │ 最快       │
│ 二级索引查询    │ 6-8个块      │ 少量记录     │ 较快       │
│ 覆盖索引查询    │ 3-5个块      │ 少量记录     │ 快         │
└─────────────────┴──────────────┴──────────────┴────────────┘
```

## 6. 工具实操：EXPLAIN性能分析

### 6.1 EXPLAIN基础语法

EXPLAIN是MySQL提供的查询执行计划分析工具，可以帮助我们理解查询是如何执行的。

```sql
-- 基础语法
EXPLAIN SELECT * FROM users WHERE phone = '13812345678';

-- 详细分析（MySQL 8.0+）
EXPLAIN ANALYZE SELECT * FROM users WHERE phone = '13812345678';

-- JSON格式输出（更详细）
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE phone = '13812345678';
```

### 6.2 EXPLAIN输出字段详解

| 字段 | 含义 | 重要值 |
|------|------|--------|
| **id** | 查询序列号 | 数字越大越先执行 |
| **select_type** | 查询类型 | SIMPLE, PRIMARY, SUBQUERY |
| **table** | 访问的表 | 表名或别名 |
| **type** | 连接类型 | system > const > eq_ref > ref > range > index > ALL |
| **possible_keys** | 可能使用的索引 | 索引名列表 |
| **key** | 实际使用的索引 | 索引名 |
| **key_len** | 索引长度 | 字节数 |
| **ref** | 索引比较的列 | 常量或列名 |
| **rows** | 预估扫描行数 | 数字越小越好 |
| **Extra** | 额外信息 | Using index, Using filesort等 |

### 6.3 实战案例分析

#### 案例1：全表扫描分析
```sql
-- 查询语句
SELECT * FROM users WHERE age = 25;

-- EXPLAIN结果
EXPLAIN SELECT * FROM users WHERE age = 25;
```

**输出结果：**
```
+----+-------------+-------+------+---------------+------+---------+------+----------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows     | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+----------+-------------+
|  1 | SIMPLE      | users | ALL  | NULL          | NULL | NULL    | NULL | 10000000 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+----------+-------------+
```

**分析：**
- `type: ALL` - 全表扫描，性能最差
- `rows: 10000000` - 需要扫描1000万行
- `Extra: Using where` - 在内存中过滤条件

#### 案例2：索引优化后分析
```sql
-- 添加索引
ALTER TABLE users ADD INDEX idx_age(age);

-- 再次分析
EXPLAIN SELECT * FROM users WHERE age = 25;
```

**输出结果：**
```
+----+-------------+-------+------+---------------+---------+---------+-------+--------+-------+
| id | select_type | table | type | possible_keys | key     | key_len | ref   | rows   | Extra |
+----+-------------+-------+------+---------------+---------+---------+-------+--------+-------+
|  1 | SIMPLE      | users | ref  | idx_age       | idx_age | 4       | const | 150000 | NULL  |
+----+-------------+-------+------+---------------+---------+---------+-------+--------+-------+
```

**分析：**
- `type: ref` - 使用非唯一索引，性能良好
- `key: idx_age` - 使用了age索引
- `rows: 150000` - 预估扫描15万行（大幅减少）

#### 案例3：复合索引分析
```sql
-- 复合索引查询
EXPLAIN SELECT * FROM users WHERE age = 25 AND city = '北京';
```

**使用idx_age_city索引的结果：**
```
+----+-------------+-------+------+---------------+-------------+---------+-------------+------+-------+
| id | select_type | table | type | possible_keys | key         | key_len | ref         | rows | Extra |
+----+-------------+-------+------+---------------+-------------+---------+-------------+------+-------+
|  1 | SIMPLE      | users | ref  | idx_age_city  | idx_age_city| 54      | const,const | 5000 | NULL  |
+----+-------------+-------+------+---------------+-------------+---------+-------------+------+-------+
```

**分析：**
- `key_len: 54` - 使用了复合索引的两个字段（age: 4字节 + city: 50字节）
- `ref: const,const` - 两个字段都是常量比较
- `rows: 5000` - 进一步减少扫描行数

### 6.4 性能优化实操步骤

#### 步骤1：识别慢查询
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 超过1秒的查询记录

-- 查看慢查询
SHOW VARIABLES LIKE 'slow_query_log%';
```

#### 步骤2：使用EXPLAIN分析
```sql
-- 分析具体的慢查询
EXPLAIN SELECT * FROM users 
WHERE age BETWEEN 25 AND 35 
  AND city = '北京' 
  AND register_time > '2023-01-01';
```

#### 步骤3：优化索引策略
```sql
-- 根据查询模式创建合适的索引
ALTER TABLE users ADD INDEX idx_city_age_register(city, age, register_time);

-- 验证优化效果
EXPLAIN SELECT * FROM users 
WHERE age BETWEEN 25 AND 35 
  AND city = '北京' 
  AND register_time > '2023-01-01';
```

### 6.5 其他性能分析工具

#### SHOW PROFILE
```sql
-- 开启profiling
SET profiling = 1;

-- 执行查询
SELECT * FROM users WHERE phone = '13812345678';

-- 查看详细的执行时间
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;
```

#### Performance Schema
```sql
-- 查看最耗时的语句
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000000 AS avg_time_sec
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;
```

#### MySQL Workbench可视化分析
- Visual Explain：图形化显示执行计划
- Performance Dashboard：实时性能监控
- Query Stats：查询统计分析

### 6.6 实操练习

**练习1：分析索引失效**
```sql
-- 分析这个查询为什么慢
EXPLAIN SELECT * FROM users WHERE YEAR(register_time) = 2023;

-- 优化并对比
EXPLAIN SELECT * FROM users 
WHERE register_time >= '2023-01-01' 
  AND register_time < '2024-01-01';
```

**练习2：复合索引优化**
```sql
-- 分析最佳索引顺序
EXPLAIN SELECT * FROM users WHERE city = '北京' AND age > 25;
EXPLAIN SELECT * FROM users WHERE age > 25 AND city = '北京';

-- 测试不同的索引组合
ALTER TABLE users ADD INDEX idx_city_age(city, age);
ALTER TABLE users ADD INDEX idx_age_city(age, city);
```

**练习3：覆盖索引应用**
```sql
-- 对比是否需要回表
EXPLAIN SELECT user_id, phone FROM users WHERE phone = '13812345678';
EXPLAIN SELECT * FROM users WHERE phone = '13812345678';
```

### 8.5 索引设计原则

#### 建立索引的场景
1. **频繁查询的列**：WHERE、ORDER BY、GROUP BY中的列
2. **高选择性的列**：重复值少的列
3. **组合查询**：多列组合查询建立组合索引

#### 避免建立索引的场景
1. **频繁更新的列**：会导致频繁的索引维护
2. **低选择性的列**：如性别、状态等
3. **大字段**：TEXT、BLOB等大字段

#### 索引维护成本
```
空间成本：索引需要额外的存储空间
时间成本：INSERT、UPDATE、DELETE需要维护索引
维护成本：页分裂、合并等操作
```

---

## 9. 性能优化实战

### 9.1 EXPLAIN执行计划分析

#### 关键字段解读
```sql
EXPLAIN SELECT * FROM user WHERE age = 18 AND name = '张三';
```

| 字段 | 说明 |
|------|------|
| type | 连接类型（const > eq_ref > ref > range > index > ALL） |
| key | 实际使用的索引 |
| rows | 预估扫描行数 |
| Extra | 额外信息（Using index、Using filesort等） |

### 9.2 SQL调优策略

#### 查询优化
```sql
-- 避免SELECT *
SELECT id, name FROM user WHERE age = 18;

-- 使用覆盖索引
SELECT age, name FROM user WHERE age BETWEEN 18 AND 25;

-- 合理使用LIMIT
SELECT * FROM user WHERE age = 18 LIMIT 10;
```

#### 索引优化
```sql
-- 建立合适的组合索引
ALTER TABLE user ADD INDEX idx_age_status_name(age, status, name);

-- 删除冗余索引
DROP INDEX idx_age ON user;  -- 如果已有idx_age_name
```

---

## 10. 总结

### 10.1 MySQL索引演进历程
```
磁盘存储（扇区/块）
    ↓
Page页面概念
    ↓
Page链表连接
    ↓
一级索引出现
    ↓
多级索引演进
    ↓
B+树形成
    ↓
索引优化策略
```

### 10.2 核心要点
1. **存储基础**：理解磁盘存储特性是索引设计的基础
2. **Page概念**：Page是MySQL数据管理的核心单位
3. **B+树本质**：B+树是完美的多级索引系统，形成稠密索引
4. **关键特性**：所有键值在叶子节点、记录指针只在叶子节点、链表连接
5. **索引策略**：合理的索引设计是性能优化的关键

### 10.3 最佳实践
1. **主键设计**：使用自增整数作为主键
2. **索引选择**：根据查询模式建立合适的索引
3. **性能监控**：定期分析慢查询和执行计划
4. **持续优化**：根据业务变化调整索引策略

## 7. 优化策略：索引设计最佳实践

### 7.1 索引设计原则

#### 原则1：基于查询模式设计索引
```sql
-- 分析实际的查询模式
-- 单列查询
SELECT * FROM users WHERE phone = '13812345678';  -- 需要 idx_phone

-- 多列组合查询
SELECT * FROM users WHERE city = '北京' AND age > 25;  -- 需要 idx_city_age

-- 排序查询
SELECT * FROM users WHERE city = '北京' ORDER BY register_time;  -- 需要 idx_city_register_time
```

#### 原则2：遵循最左前缀原则
```sql
-- 复合索引：idx_city_age_register_time(city, age, register_time)

-- ✅ 可以使用索引的查询
WHERE city = '北京'                                    -- 使用 city
WHERE city = '北京' AND age > 25                       -- 使用 city, age  
WHERE city = '北京' AND age > 25 AND register_time > '2023-01-01'  -- 使用全部

-- ❌ 无法使用索引的查询
WHERE age > 25                                         -- 跳过了 city
WHERE register_time > '2023-01-01'                     -- 跳过了 city, age
```

#### 原则3：选择性高的列放在前面
```sql
-- 分析列的选择性
SELECT 
    COUNT(DISTINCT city) / COUNT(*) AS city_selectivity,
    COUNT(DISTINCT age) / COUNT(*) AS age_selectivity,
    COUNT(DISTINCT phone) / COUNT(*) AS phone_selectivity
FROM users;

-- 结果示例：
-- city_selectivity: 0.001 (1000个不同城市/1000万记录)
-- age_selectivity: 0.008 (80个不同年龄/1000万记录)  
-- phone_selectivity: 1.0 (每个手机号都不同)

-- 索引顺序建议：phone > city > age
```

### 7.2 索引维护策略

#### 定期分析索引使用情况
```sql
-- 查看索引使用统计
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    SEQ_IN_INDEX,
    COLUMN_NAME
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' 
  AND TABLE_NAME = 'users';

-- 查看未使用的索引（MySQL 8.0+）
SELECT 
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE index_name IS NOT NULL 
  AND count_star = 0 
  AND object_schema = 'your_database';
```

#### 删除冗余索引
```sql
-- 示例：如果有 idx_city_age，就不需要单独的 idx_city
-- 因为 idx_city_age 可以覆盖对 city 的查询

-- 查找可能的冗余索引
SELECT 
    a.TABLE_SCHEMA,
    a.TABLE_NAME,
    a.INDEX_NAME as index1,
    b.INDEX_NAME as index2
FROM information_schema.STATISTICS a
JOIN information_schema.STATISTICS b ON 
    a.TABLE_SCHEMA = b.TABLE_SCHEMA 
    AND a.TABLE_NAME = b.TABLE_NAME
    AND a.COLUMN_NAME = b.COLUMN_NAME
    AND a.INDEX_NAME != b.INDEX_NAME
WHERE a.TABLE_SCHEMA = 'your_database';
```

### 7.3 特殊场景优化

#### 大表分页优化
```sql
-- ❌ 传统分页（深度分页性能差）
SELECT * FROM users ORDER BY user_id LIMIT 1000000, 20;

-- ✅ 基于索引的分页
SELECT * FROM users WHERE user_id > 1000000 ORDER BY user_id LIMIT 20;

-- ✅ 延迟关联优化
SELECT u.* FROM users u
INNER JOIN (
    SELECT user_id FROM users ORDER BY user_id LIMIT 1000000, 20
) t ON u.user_id = t.user_id;
```

#### 范围查询优化
```sql
-- ❌ 范围查询影响后续字段
SELECT * FROM users 
WHERE age BETWEEN 25 AND 35 
  AND city = '北京' 
  AND register_time > '2023-01-01';

-- ✅ 调整索引顺序，将范围查询放在最后
-- 索引：idx_city_register_time_age(city, register_time, age)
SELECT * FROM users 
WHERE city = '北京' 
  AND register_time > '2023-01-01'
  AND age BETWEEN 25 AND 35;
```

#### 覆盖索引应用
```sql
-- 业务场景：用户列表页面只显示基本信息
-- ❌ 需要回表的查询
SELECT user_id, username, phone, city FROM users WHERE city = '北京';

-- ✅ 创建覆盖索引
ALTER TABLE users ADD INDEX idx_city_cover(city, user_id, username, phone);

-- 现在查询无需回表，性能大幅提升
```

### 7.4 监控和告警

#### 设置性能监控
```sql
-- 监控慢查询
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 0.5;  -- 超过0.5秒记录

-- 监控索引使用率
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT,
    COUNT_UPDATE,
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_FETCH DESC;
```

#### 建立告警机制
- 慢查询数量超过阈值
- 全表扫描比例过高
- 索引使用率过低
- 数据库连接数异常

### 7.5 实战总结

#### 我们的电商系统优化成果

**优化前：**
- 用户登录：8-12秒
- 用户搜索：15-20秒  
- 数据统计：30-45秒
- 数据库CPU：90%+

**优化后：**
```sql
-- 添加的关键索引
ALTER TABLE users ADD INDEX idx_phone(phone);                    -- 登录优化
ALTER TABLE users ADD INDEX idx_city_age(city, age);            -- 搜索优化  
ALTER TABLE users ADD INDEX idx_register_time(register_time);    -- 统计优化
ALTER TABLE users ADD INDEX idx_city_cover(city, user_id, username, phone);  -- 覆盖索引
```

**性能提升：**
- 用户登录：0.1-0.3秒（提升97%）
- 用户搜索：0.5-1秒（提升95%）
- 数据统计：2-3秒（提升90%）
- 数据库CPU：30-40%

#### 关键经验总结

1. **理解业务场景**：索引设计必须基于实际的查询模式
2. **数据驱动优化**：使用EXPLAIN等工具分析，不要凭感觉优化
3. **平衡读写性能**：索引提升查询性能，但会影响写入性能
4. **持续监控优化**：性能优化是一个持续的过程
5. **团队协作**：建立索引设计规范，避免随意添加索引

#### 下一步学习建议

1. **深入学习B+树原理**：理解索引的底层实现
2. **掌握分区表技术**：处理超大表的性能问题
3. **学习读写分离**：通过架构优化提升整体性能
4. **研究缓存策略**：Redis等缓存技术的应用
5. **关注新特性**：MySQL 8.0的新索引特性

---

## 课程总结

通过本课程的学习，我们从一个具体的业务场景出发，深入理解了MySQL索引的设计原理和优化策略。关键收获包括：

1. **问题导向**：从实际性能问题出发，理解索引的价值
2. **原理理解**：掌握数据存储的物理基础和B+树原理
3. **工具实操**：熟练使用EXPLAIN等性能分析工具
4. **实战经验**：掌握索引失效场景和优化策略
5. **最佳实践**：建立系统化的索引设计和维护方法

记住：**性能优化没有银弹，只有基于具体场景的最佳实践。**

---

## 参考资料
- MySQL官方文档：InnoDB存储引擎
- 《高性能MySQL》第三版
- 《MySQL技术内幕：InnoDB存储引擎》
- MySQL Performance Schema文档