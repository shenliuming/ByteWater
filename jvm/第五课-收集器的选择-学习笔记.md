# 第五课：收集器的选择 - 不同场景的最佳拍档

> 根据应用场景选择最适合的垃圾收集器

---

*本课程基于Oracle JVM Specification和OpenJDK源码，确保技术内容的准确性和权威性。*

## 🎯 开篇问题

上节课我们学会了"管理员"的三大工作智慧：侦探算法、清理策略和分代管理。但是在现实世界中，不同的"收容所"有着不同的需求：

想象一下这样的场景：
```java
public class DifferentScenarios {
    public static void main(String[] args) {
        // 场景1：小型咖啡店 - 追求响应速度
        runCafeSystem();     // 不能让顾客等太久
        
        // 场景2：大型工厂 - 追求处理量
        runFactorySystem();  // 需要处理海量数据
        
        // 场景3：医院系统 - 追求稳定性
        runHospitalSystem(); // 绝对不能停机
        
        // 哪种"管理员"最适合哪种场景？
    }
}
```

**核心疑问：**
- 为什么需要不同类型的"管理员"？
- 如何为不同场景选择最合适的"管理员"？
- 这些"管理员"各有什么特长和短板？

## 🔬 核心认知：三种"管理员"的工作风格

通过三个关键实验，我们将发现不同"管理员"的工作特点：

### 🎯 现象一："快手"管理员 - Serial GC的工作方式

**实验设计：**
模拟小型"收容所"的管理场景

```java
public class SerialGCDemo {
    public static void main(String[] args) {
        System.out.println("=== 小型收容所：'快手'管理员工作演示 ===");
        
        // 设置使用Serial GC
        // JVM参数：-XX:+UseSerialGC -Xms50m -Xmx50m
        
        System.out.println("\n阶段1：正常工作时间");
        for (int i = 0; i < 1000; i++) {
            createSmallObjects();
            if (i % 100 == 0) {
                System.out.println("处理第 " + i + " 批居民");
            }
        }
        
        System.out.println("\n阶段2：观察管理员工作");
        System.gc(); // 触发垃圾回收
        
        System.out.println("\n阶段3：工作特点总结");
        System.out.println("- 管理员独自工作，专心致志");
        System.out.println("- 工作时收容所暂停接待");
        System.out.println("- 适合小型收容所");
    }
    
    private static void createSmallObjects() {
        for (int i = 0; i < 100; i++) {
            String resident = "小型居民" + i;
        }
    }
}
```

**观察现象：**
- "快手"管理员工作时，整个收容所暂停服务
- 工作效率高，但会造成短暂的"停机"
- 适合小规模、对停顿时间要求不高的场景

### 🎯 现象二："团队"管理员 - Parallel GC的协作模式

**实验设计：**
模拟中型"收容所"的团队管理

```java
public class ParallelGCDemo {
    public static void main(String[] args) {
        System.out.println("=== 中型收容所：'团队'管理员工作演示 ===");
        
        // 设置使用Parallel GC
        // JVM参数：-XX:+UseParallelGC -Xms200m -Xmx200m
        
        System.out.println("\n阶段1：大量居民涌入");
        List<Object> residents = new ArrayList<>();
        
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            residents.addAll(createMediumObjects());
            if (i % 1000 == 0) {
                System.out.println("已处理 " + i + " 批居民，当前时间：" + 
                    (System.currentTimeMillis() - startTime) + "ms");
            }
        }
        
        System.out.println("\n阶段2：团队清理工作");
        residents.clear();
        System.gc();
        
        System.out.println("\n阶段3：团队工作特点");
        System.out.println("- 多个管理员并行工作");
        System.out.println("- 清理速度快，但仍需暂停服务");
        System.out.println("- 适合中大型收容所");
    }
    
    private static List<Object> createMediumObjects() {
        List<Object> objects = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            objects.add("中型居民" + i);
        }
        return objects;
    }
}
```

**观察现象：**
- 多个"管理员"同时工作，清理效率大幅提升
- 仍然需要暂停收容所服务，但时间更短
- 适合追求吞吐量的中大型应用

### 🎯 现象三："不停机"管理员 - G1 GC的智能管理

**实验设计：**
模拟大型"收容所"的不停机管理

```java
public class G1GCDemo {
    public static void main(String[] args) {
        System.out.println("=== 大型收容所：'不停机'管理员工作演示 ===");
        
        // 设置使用G1 GC
        // JVM参数：-XX:+UseG1GC -Xms1g -Xmx1g -XX:MaxGCPauseMillis=200
        
        System.out.println("\n阶段1：持续服务模拟");
        
        // 模拟持续的业务处理
        Thread businessThread = new Thread(() -> {
            for (int i = 0; i < 50000; i++) {
                processBusinessRequest(i);
                if (i % 5000 == 0) {
                    System.out.println("[业务线程] 处理了 " + i + " 个请求");
                }
                try {
                    Thread.sleep(1); // 模拟业务处理时间
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        
        businessThread.start();
        
        System.out.println("\n阶段2：智能管理工作");
        System.out.println("- 管理员在后台智能工作");
        System.out.println("- 收容所持续对外服务");
        System.out.println("- 停顿时间可控制在200ms以内");
        
        try {
            businessThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("\n阶段3：智能管理特点");
        System.out.println("- 低延迟：停顿时间可预测");
        System.out.println("- 高吞吐：并发清理不影响业务");
        System.out.println("- 适合大型、对响应时间敏感的系统");
    }
    
    private static void processBusinessRequest(int requestId) {
        // 模拟业务处理，创建一些对象
        List<String> data = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            data.add("请求" + requestId + "的数据" + i);
        }
        // 模拟数据处理
        data.stream().filter(s -> s.contains("数据")).count();
    }
}
```

**观察现象：**
- "不停机"管理员在后台智能工作
- 业务处理几乎不受影响
- 停顿时间可控，适合对响应时间敏感的大型系统

## 🎓 深入理解：垃圾收集器的"人格特质"

### 📖 特质一：Serial GC - "专注的独行侠"

**工作哲学：**
```
专注模式：一心一意做好一件事
工作方式：Stop-The-World，单线程清理
适用场景：小型应用、客户端程序
```

**优势：**
- 简单可靠，资源消耗少
- 在小堆内存下效率很高
- 没有线程切换开销

**劣势：**
- 停顿时间随堆大小增长
- 不适合多核环境
- 无法利用现代硬件优势

### 📖 特质二：Parallel GC - "高效的团队合作者"

**工作哲学：**
```
团队协作：多人协作，提高效率
工作方式：Stop-The-World，多线程并行清理
适用场景：服务器应用、批处理系统
```

**优势：**
- 充分利用多核CPU
- 吞吐量高，适合批处理
- 成熟稳定，广泛使用

**劣势：**
- 停顿时间仍然较长
- 不适合对延迟敏感的应用
- 老年代清理时停顿明显

### 📖 特质三：G1 GC - "智能的平衡大师"

**工作哲学：**
```
智能平衡：在吞吐量和延迟间找平衡
工作方式：大部分时间并发，少量Stop-The-World
适用场景：大内存、低延迟要求的应用
```

**优势：**
- 可预测的停顿时间
- 适合大堆内存（>4GB）
- 并发标记和清理
- 分区管理，局部回收

**劣势：**
- 算法复杂，调优困难
- 在小堆上可能不如Parallel GC
- 内存占用相对较高

## 💡 核心概念总结

### 实验总结
通过三个实验，我们发现了垃圾收集器的三种"人格"：
1. **Serial GC**：专注的独行侠，适合小规模应用
2. **Parallel GC**：高效的团队，适合追求吞吐量的应用
3. **G1 GC**：智能的平衡大师，适合大型低延迟应用

### 核心认知

#### 1. 选择的智慧
- **应用规模**：小型选Serial，中大型选Parallel，超大型选G1
- **性能要求**：追求吞吐量选Parallel，追求低延迟选G1
- **硬件环境**：单核选Serial，多核选Parallel或G1

#### 2. 没有"最好"，只有"最合适"
- **咖啡店场景**：Serial GC，简单可靠
- **工厂场景**：Parallel GC，高吞吐量
- **医院场景**：G1 GC，低延迟稳定

#### 3. 性能调优的方向
- **Serial GC**：主要调整堆大小
- **Parallel GC**：调整并行线程数和堆大小
- **G1 GC**：设置停顿时间目标和分区大小

### 编程启示

1. **了解你的应用特性**
   - 是CPU密集型还是IO密集型？
   - 对延迟敏感还是对吞吐量敏感？
   - 堆内存使用模式如何？

2. **选择合适的收集器**
   - 不要盲目追求"最新"的收集器
   - 根据实际需求做出选择
   - 在生产环境中充分测试

3. **持续监控和调优**
   - 监控GC日志和性能指标
   - 根据实际表现调整参数
   - 随着应用发展重新评估选择

## 🤔 课后思考题

### 动手实验题
1. **收集器对比实验**
   - 编写一个程序，分别使用三种收集器运行
   - 对比它们的GC日志，观察停顿时间和频率的差异
   - 记录你的发现和分析

2. **参数调优实验**
   - 对G1 GC设置不同的MaxGCPauseMillis值（50ms, 100ms, 200ms）
   - 观察对应用性能的影响
   - 找到最适合的平衡点

### 现象观察题
1. **生活中的"收集器"选择**
   - 家庭清洁：一个人打扫 vs 全家一起打扫 vs 请保洁阿姨
   - 这三种方式分别对应哪种垃圾收集器？为什么？

2. **应用场景分析**
   - 在线游戏服务器应该选择哪种收集器？为什么？
   - 大数据批处理应用应该选择哪种收集器？为什么？
   - 移动应用的后端服务应该选择哪种收集器？为什么？

### 深度思考题
1. **权衡的艺术**
   - 为什么不能设计一个"完美"的垃圾收集器？
   - 吞吐量和延迟为什么往往是矛盾的？
   - 如何在实际项目中做出最佳选择？

2. **未来的发展**
   - 随着硬件的发展，垃圾收集器会如何演进？
   - ZGC和Shenandoah等新收集器解决了什么问题？
   - 你认为垃圾收集器的未来发展方向是什么？

## 🔮 下节预告：性能调优的艺术

通过这节课，我们认识了三种不同"人格"的垃圾收集器，知道了如何为不同场景选择最合适的"管理员"。但是你有没有好奇：

### 🤔 调优的挑战

即使选对了收集器，在实际生产环境中，我们还会遇到各种"意外"：

- **🚨 突发状况**：为什么应用突然变慢了？
- **📊 数据迷雾**：如何从海量监控数据中找到问题根源？
- **⚡ 优化策略**：如何系统性地进行性能调优？

### 🎯 下节课预告：《第六课：调优大师的秘籍 - 从监控到优化的完整攻略》

我们将通过实战案例学习：
1. **监控体系**：如何建立完整的JVM监控体系？
2. **问题诊断**：如何快速定位性能瓶颈？
3. **调优实战**：如何制定和执行调优策略？

如果让你设计一套"收容所监控系统"，你会：
- 监控哪些关键指标？
- 如何快速发现异常？
- 如何制定改进方案？

让我们一起成为JVM调优大师！ 🚀