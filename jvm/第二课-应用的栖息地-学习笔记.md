# 第二课：应用的栖息地 - JVM内存区域探秘

> 当main线程执行代码时，JVM内存中究竟发生了什么？

---

*本课程基于Oracle JVM Specification和OpenJDK源码，确保技术内容的准确性和权威性。*

## 开篇：从现象看内存

上节课我们发现了一个重要现象：当你在cmd中运行`java HelloWorld`时，会启动一个JVM进程。

**但是你有没有想过：**
- 这个JVM进程占用了多少内存？
- 你的代码和数据存放在内存的哪里？
- 为什么有时候会出现"内存溢出"错误？

让我们通过实际现象来探索JVM内存的秘密！

## 核心认知：从内存使用的真实现象开始

### 🎯 现象一：JVM进程真的在占用内存

**实验准备：**
```java
// MemoryDemo.java
public class MemoryDemo {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("我是一个Java应用，我正在占用内存！");
        
        // 让程序暂停30秒，方便观察
        Thread.sleep(30000);
        
        System.out.println("我要结束了");
    }
}
```

**观察步骤：**
1. 编译并运行这个程序：`java MemoryDemo`
2. 立即打开任务管理器
3. 找到java.exe进程，查看"内存"列

**你会发现：**
- java.exe进程占用了几十MB的内存（比如64MB）
- 即使你的代码只有几行，JVM也需要这么多内存
- **这说明JVM为了运行你的代码，在内存中准备了很多"房间"**

### 🎯 现象二：不同的代码占用不同的内存

**创建一个"内存大户"：**
```java
// BigMemoryDemo.java
public class BigMemoryDemo {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("我要创建很多对象！");
        
        // 创建100万个字符串对象
        String[] strings = new String[1000000];
        for (int i = 0; i < 1000000; i++) {
            strings[i] = "Hello World " + i;
        }
        
        System.out.println("创建完成，我现在占用更多内存了！");
        Thread.sleep(30000); // 暂停30秒观察
    }
}
```

**对比实验：**
1. 先运行简单的`MemoryDemo`，记录内存占用
2. 再运行`BigMemoryDemo`，观察内存变化

**震撼发现：**
- `BigMemoryDemo`占用的内存明显更多（可能200MB+）
- **这证明：你创建的对象确实存储在JVM内存中**
- **不同的代码需要不同大小的内存空间**

### 🎯 现象三：内存不够时JVM会"抗议"

**制造内存溢出：**
```java
// OutOfMemoryDemo.java
public class OutOfMemoryDemo {
    public static void main(String[] args) {
        System.out.println("我要把内存撑爆！");
        
        java.util.List<String> list = new java.util.ArrayList<>();
        
        try {
            // 无限创建对象，直到内存不够
            while (true) {
                list.add("这是一个很长很长很长的字符串，用来占用内存" + System.currentTimeMillis());
            }
        } catch (OutOfMemoryError e) {
            System.out.println("内存不够了！JVM抗议了：" + e.getMessage());
        }
    }
}
```

**运行结果：**
```
我要把内存撑爆！
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```

**关键发现：**
- JVM会报告"Java heap space"内存不足
- **这说明对象存储在叫"heap"（堆）的地方**
- **当堆内存不够时，JVM会抛出OutOfMemoryError**

## 深入理解：JVM内存的"房间布局"

通过上面的实验，我们发现JVM内存不是一个整体，而是分成了不同的"房间"。让我们看看这些房间的作用：

### 🏠 房间一：堆内存（Heap）- 对象的家

**作用：存放你创建的所有对象**

```java
public class HeapDemo {
    public static void main(String[] args) {
        // 这些对象都存储在堆内存中
        String name = "张三";           // 字符串对象 → 堆
        int[] numbers = {1, 2, 3};      // 数组对象 → 堆
        java.util.List<String> list = new java.util.ArrayList<>(); // List对象 → 堆
        
        System.out.println("所有对象都在堆内存中安家了！");
    }
}
```

**关键特点：**
- 所有用`new`创建的对象都在堆中
- 字符串、数组、集合等都是对象，都在堆中
- 堆内存不够时会出现`OutOfMemoryError: Java heap space`
- **堆是JVM内存中最大的区域**

### 🏠 房间二：虚拟机栈（VM Stack）- 方法的工作台

**作用：存放方法执行时的局部变量和方法调用信息**

```java
public class StackDemo {
    public static void main(String[] args) {
        System.out.println("main方法开始执行");
        method1();
        System.out.println("main方法执行结束");
    }
    
    public static void method1() {
        int a = 10;        // 局部变量a存储在栈中
        String b = "hello"; // 变量b存储在栈中（但"hello"对象在堆中）
        System.out.println("method1执行中");
        method2();
    }
    
    public static void method2() {
        int c = 20;        // 局部变量c存储在栈中
        System.out.println("method2执行中");
    }
}
```

**栈的工作过程：**
```
1. main方法开始 → 在栈中创建main方法的"工作台"
2. 调用method1 → 在栈中创建method1的"工作台"
3. 调用method2 → 在栈中创建method2的"工作台"
4. method2结束 → 销毁method2的"工作台"
5. method1结束 → 销毁method1的"工作台"
6. main结束 → 销毁main的"工作台"
```

**栈溢出实验：**
```java
public class StackOverflowDemo {
    public static void main(String[] args) {
        recursiveMethod(1);
    }
    
    public static void recursiveMethod(int count) {
        System.out.println("递归调用第 " + count + " 次");
        recursiveMethod(count + 1); // 无限递归
    }
}
```

**运行结果：**
```
递归调用第 1 次
递归调用第 2 次
...
递归调用第 15000 次
Exception in thread "main" java.lang.StackOverflowError
```

**关键发现：**
- 方法调用太深会导致`StackOverflowError`
- **这证明方法调用信息确实存储在栈中**

### 🏠 房间三：方法区（Method Area）- 类信息的图书馆

**作用：存放类的信息、常量、静态变量等**

```java
public class MethodAreaDemo {
    // 静态变量存储在方法区
    public static String staticVar = "我在方法区";
    
    // 常量存储在方法区
    public static final String CONSTANT = "我是常量，也在方法区";
    
    public static void main(String[] args) {
        System.out.println(staticVar);
        System.out.println(CONSTANT);
        
        // 类信息也在方法区
        System.out.println("当前类名：" + MethodAreaDemo.class.getName());
    }
}
```

**方法区存储的内容：**
- 类的基本信息（类名、父类、接口等）
- 方法的字节码
- 静态变量
- 常量池

### 🏠 房间四：程序计数器（PC Register）- 执行进度的指示器

**作用：记录当前线程执行到哪一行代码**

```java
public class PCDemo {
    public static void main(String[] args) {
        System.out.println("第1行代码");  // PC指向这里
        System.out.println("第2行代码");  // 然后PC指向这里
        System.out.println("第3行代码");  // 最后PC指向这里
    }
}
```

**关键理解：**
- 每个线程都有自己的程序计数器
- 程序计数器记录当前执行的字节码指令位置
- **这就是为什么程序能按顺序执行的原因**

## 实战体验：观察内存区域的真实工作

### 🔬 实验一：观察堆内存的增长

```java
public class HeapGrowthDemo {
    public static void main(String[] args) throws InterruptedException {
        // 获取运行时信息
        Runtime runtime = Runtime.getRuntime();
        
        System.out.println("=== 程序开始时的内存状态 ===");
        printMemoryInfo(runtime);
        
        // 创建大量对象
        String[] bigArray = new String[500000];
        for (int i = 0; i < 500000; i++) {
            bigArray[i] = "Object " + i;
        }
        
        System.out.println("\n=== 创建对象后的内存状态 ===");
        printMemoryInfo(runtime);
        
        Thread.sleep(10000); // 暂停10秒观察
    }
    
    public static void printMemoryInfo(Runtime runtime) {
        long totalMemory = runtime.totalMemory() / 1024 / 1024;  // MB
        long freeMemory = runtime.freeMemory() / 1024 / 1024;    // MB
        long usedMemory = totalMemory - freeMemory;              // MB
        
        System.out.println("总内存: " + totalMemory + " MB");
        System.out.println("已用内存: " + usedMemory + " MB");
        System.out.println("空闲内存: " + freeMemory + " MB");
    }
}
```

**运行结果示例：**
```
=== 程序开始时的内存状态 ===
总内存: 245 MB
已用内存: 2 MB
空闲内存: 243 MB

=== 创建对象后的内存状态 ===
总内存: 245 MB
已用内存: 45 MB
空闲内存: 200 MB
```

**关键发现：**
- 创建对象确实增加了内存使用
- **你可以实时监控堆内存的使用情况**

### 🔬 实验二：观察栈的深度限制

```java
public class StackDepthDemo {
    private static int depth = 0;
    
    public static void main(String[] args) {
        try {
            recursiveCall();
        } catch (StackOverflowError e) {
            System.out.println("栈溢出了！最大递归深度: " + depth);
        }
    }
    
    public static void recursiveCall() {
        depth++;
        recursiveCall(); // 递归调用
    }
}
```

**运行结果示例：**
```
栈溢出了！最大递归深度: 15326
```

**关键发现：**
- 栈的深度是有限制的
- **不同的JVM配置会有不同的栈深度限制**

## 🎯 核心概念总结

通过实际实验，我们发现了JVM内存的真实结构：

### 💡 四个内存区域的分工

**堆内存（Heap）：对象的家**
- 存储所有用`new`创建的对象
- 内存不够时抛出`OutOfMemoryError: Java heap space`
- 是JVM中最大的内存区域

**虚拟机栈（VM Stack）：方法的工作台**
- 存储方法的局部变量和调用信息
- 每个方法调用都会在栈中创建一个"工作台"
- 递归太深会导致`StackOverflowError`

**方法区（Method Area）：类信息的图书馆**
- 存储类的基本信息、静态变量、常量
- 所有线程共享这个区域

**程序计数器（PC Register）：执行进度的指示器**
- 记录当前线程执行到哪一行代码
- 每个线程都有自己的程序计数器

### 🔄 一行代码的内存之旅

当main线程执行`System.out.println("Hello, World!")`时：

```
1. 程序计数器 → 指向这行代码的位置
2. 虚拟机栈 → 为main方法创建工作台，存储局部变量
3. 方法区 → 查找System类和println方法的信息
4. 堆内存 → 存储"Hello, World!"字符串对象
5. 虚拟机栈 → 调用println方法，创建新的工作台
6. 程序计数器 → 更新执行位置
```

## 🤔 课后思考题

**实验验证题：**
1. 创建1000万个对象，观察堆内存的变化
2. 写一个递归方法，测试你的JVM栈深度限制
3. 创建多个静态变量，它们存储在哪个内存区域？

**现象观察题：**
4. 为什么局部变量不会导致内存泄漏？
5. 为什么静态变量在程序结束前一直存在？

**思考题：**
6. 如果堆内存不够了，JVM会怎么办？
7. 为什么每个线程需要自己的栈和程序计数器？

## 🚀 下节预告：生命的维护

下一课我们将探索JVM的"清洁工"：

**核心问题**：当堆内存中的对象越来越多时，JVM如何自动清理？
- 什么是垃圾回收？
- JVM如何判断对象是垃圾？
- 垃圾回收时程序会停止吗？
- 为什么有时候垃圾回收很慢？

我们将继续通过实际现象来观察垃圾回收的工作过程！

---

> **今日收获**：从内存使用的实际现象中，我们发现了JVM内存的四个"房间" —— 堆存对象、栈存方法、方法区存类信息、程序计数器记录执行位置。理解了内存布局，就理解了Java程序运行的物理基础！